Синтаксис правил, повторяемость и опциональность
================================================

Общая информация
----------------

Грамматика (нетерминал) - описывает словосочетание, например пару слов - прилагательное + существительное.

Правило (терминал) - описывает отдельное слово или группу схожих слов

Класс грамматик - объединяет несколько семантически схожих грамматик

Синтаксис
---------

.. code-block:: python

   from enum import Enum
   from yargy.labels import gram

   class Grammars(Enum):
       '''
       Класс грамматик, описывающий аттрибуты персоны
       '''

       # грамматика представляет собой список, который
       # может содержать одно и более правило
       # в данном случае, всего одно
       Name = [
           # каждое правило представляет из себя словарь
           # с специальными полями - например, 'labels' - список лейблов,
           # по которым будет произодиться поиск
           {
               'labels': [
                   gram('Name'), # специальный лейбл, проверяющий наличие передаваемой грамеммы в морф. разборе слова
               ]
           }
       ]

Опциональность и повторяемость
------------------------------

Для правил можно задать свойства повторяемости. Для примера, рассмотрим грамматику выделяющую названия улиц:

.. code-block:: python

   from enum import Enum
   from yargy.labels import (
       gram,
       is_capitalized,
       gnc_match,
       dictionary,
   )

   class StreetName(Enum):

       AdjNoun = [
           {
               'labels': [
                   gram('ADJF') # прилагательное (полное)
                   is_capitalized(True) # с заглавной буквы
               ],
           },
           {
               'labels': [
                   gram('ADJF'), # тоже прилагательное
                   gnc_match(-1), # согласующееся с предыдущим словом по роду, числу и падежу
               ],
               'optional': True, # опциональное
               'repeatable': True, # повторяющееся один и более раз
               # опциональное + повторяемое = повторяемое 0 и более раз
           },
           {
               'labels': [
                   dictionary({ # совпадение по нормальной форме слова
                       'улица',
                       'проспект',
                   }),
                   gnc_match(-1), # согласующееся с предыдущим словом
               ]
           },
       ]

В этом случае, парсер будет выделять сущности навроде **Большая садовая улица** или **Гражданский проспект**, но не **красивый улица** т.к. между словами нет согласования.

Разрешение неоднозначности при разборе правил
---------------------------------------------

Если словосочетание одновременно попадает под несколько (пересекающихся) грамматик, можно использовать специальный метод для разрешения неоднозначности:

.. code-block:: python

   from natasha import Combinator
   from natasha.grammars import Person

   combinator = Combinator([Person])

   # каждое слово в этом тексте попадает под несколько стандартных грамматик,
   # которые определены в классе Person
   text = 'иван федорович сидоров'

   # сейчас matches содержит все совпадения, найденные парсером
   matches = list(
       combinator.extract(text)
   )
   assert len(matches) > 1

   # можно снять неоднозначность по кол-ву токенов
   # используя специальный метод - resolve_matches
   # который исключит совпадения, содержащиеся внутри других совпадений
   matches = list(
       combinator.resolve_matches(matches)
   )
   assert len(matches) == 1
   
   # получаем правило и строки, извлеченные парсером
   grammar, tokens = matches[0]
   assert grammar == Person.FullReversed
   assert [t.value for t in tokens] == ['иван', 'федорович', 'сидоров']

Также, метод `resolve_matches` принимает дополнительный именной аргумент - `strict`, который определяет разрешение совпадений по классу грамматики, например:

.. code-block:: python

   from natasha import Combinator
   from natasha.grammars import Person, Organisation

   # здесь можно выделить несколько сущностей:
   text = 'представитель администрации президента россии федор смирнов'

   combinator = Combinator([
       Person,
       Organisation,
   ])
   matches = combinator.resolve_matches(combinator.extract(text), strict=False)
   matches = ((grammar, [t.value for t in tokens]) for (grammar, tokens) in matches)

   assert list(matches) == [
       (Person.WithPosition, ['представитель', 'администрации', 'президента', 'россии', 'федор', 'смирнов']),
       (Organisation.Social, ['администрации', 'президента', 'россии']),
   ]
